<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Solar System with Moving Stones</title>
  <style>
    * { margin: 0; padding: 0; }
    body { overflow: hidden; background: black; }
    canvas { display: block; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.16.0/dist/gsap.min.js"></script>
</head>
<body>

<script type="module">
import * as THREE from "https://cdn.skypack.dev/three@0.129.0";
import { OrbitControls } from "https://cdn.skypack.dev/three@0.129.0/examples/jsm/controls/OrbitControls.js";
// Import BufferGeometryUtils for merging geometries
import { BufferGeometryUtils } from "https://cdn.skypack.dev/three@0.129.0/examples/jsm/utils/BufferGeometryUtils.js";

// --- Scene & Camera ---
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(85, window.innerWidth / window.innerHeight, 0.1, 10000);
camera.position.set(0, 150, 400);

// --- Renderer ---
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- Orbit Controls ---
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.2;
controls.enablePan = true;
controls.panSpeed = 4;
controls.enableZoom = true;
controls.minDistance = 1;
controls.maxDistance = 1500;
controls.zoomSpeed = 2;
controls.rotateSpeed = 1;

// --- Lights ---
const ambientLight = new THREE.AmbientLight(0xffffff, 1);
scene.add(ambientLight);
const sunLight = new THREE.PointLight(0xffffff, 0.5, 1000);
sunLight.position.set(0,0,0);
scene.add(sunLight);

// --- Ellipse rings (super thin line) ---
function createEllipseRing(radiusX, radiusY, centrex = 0, segments = 200) {
  const points = [];
  for (let i = 0; i <= segments; i++) {
    const theta = (i / segments) * 2 * Math.PI;
    const x = radiusX * Math.cos(theta) + centrex;
    const z = radiusY * Math.sin(theta);
    points.push(new THREE.Vector3(x, 0, z));
  }

  const geometry = new THREE.BufferGeometry().setFromPoints(points);

  const material = new THREE.LineBasicMaterial({
    color: 0x00AEEF,
    transparent: true,
    opacity: 0.1,
    linewidth: 1
  });

  const line = new THREE.LineLoop(geometry, material);
  scene.add(line);
  return line;
}

// --- Orbits data ---
const orbitsData = [
  { a: 9.097,   b: 8.902594,  cx: -0.361 },   // Mercury
  { a: 16.998,  b: 16.997610, cx: -0.011 },   // Venus
  { a: 23.5,    b: 23.496719, cx: -0.392 },   // Earth
  { a: 35.806,  b: 35.649507, cx: -0.667 },   // Mars
  { a: 122.279, b: 122.135775, cx: -2.519 },  // Jupiter
  { a: 224.121, b: 223.795666, cx: -8.436 },  // Saturn
  { a: 450.995, b: 450.491123, cx: -9.868 },  // Uranus
  { a: 706.621, b: 706.594926, cx: -5.462 },  // Neptune
];

orbitsData.forEach(o => createEllipseRing(o.a, o.b, o.cx, 50));

// --- Planets ---
const textureLoader = new THREE.TextureLoader();
function loadPlanetTexture(texture, radius, widthSegments, heightSegments) {
  const geometry = new THREE.SphereGeometry(radius, widthSegments, heightSegments);
  const planetTexture = textureLoader.load(texture);
  const material = new THREE.MeshStandardMaterial({ map: planetTexture });
  return new THREE.Mesh(geometry, material);
}

const planets = [
  { mesh: loadPlanetTexture("./img/8k_sun.jpg", 5, 100, 100), speed: 0 },
  { mesh: loadPlanetTexture("./img/8k_mercury.jpg", 1 , 100, 100), speed: 0.4 },
  { mesh: loadPlanetTexture("./img/8k_venus_surface.jpg", 2.3, 100, 100), speed: 0.00015 },
  { mesh: loadPlanetTexture("./img/earth_day_4096.jpg", 2.3, 100, 100), speed: 0.0001 },
  { mesh: loadPlanetTexture("./img/8k_mars.jpg",  2, 100, 100), speed: 0.0008 },
  { mesh: loadPlanetTexture("./img/8k_jupiter.jpg", 4, 100, 100), speed: 0.0002 },
  { mesh: loadPlanetTexture("./img/8k_saturn.jpg", 4, 100, 100), speed: 0.00015 },
  { mesh: loadPlanetTexture("./img/2k_uranus.jpg", 4, 100, 100), speed: 0.00007 },
  { mesh: loadPlanetTexture("./img/2k_neptune.jpg", 8, 100, 100), speed: 0.000005 },
];

planets.forEach(p => scene.add(p.mesh));

// --- Stones between ellipses ---
const stoneTexture = textureLoader.load('./img/download2.jpeg');

function getRandomGeometry() {
    const geometries = [
        new THREE.IcosahedronBufferGeometry(0.3, 1),
        new THREE.TetrahedronBufferGeometry(0.3, 0),
        new THREE.DodecahedronBufferGeometry(0.3, 0),
        new THREE.SphereGeometry(0.3, 16, 16)
    ];
    return geometries[Math.floor(Math.random() * geometries.length)];
}

const movingStones = [];

function createStone(geometry, x, z, a, b, cx, speed) {
    const material = new THREE.MeshStandardMaterial({
        map: stoneTexture,
        roughness: 0.3,
        metalness: 0.5,
        emissive: new THREE.Color(0xffffff),
        emissiveIntensity: 0.3,
    });
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.set(x, 0.3, z);
    mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
    scene.add(mesh);
    movingStones.push({ mesh, a, b, cx, theta: Math.atan2(z/b, (x-cx)/a), speed });
}

function placeStonesBetweenEllipses(a1,b1,a2,b2,cx,s) {
    for(let i=0;i<s;i++){
        const t = Math.random();
        const a = a1 + t*(a2-a1);
        const b = b1 + t*(b2-b1);
        const theta = Math.random()*2*Math.PI;
        const x = cx + a*Math.cos(theta);
        const z = b*Math.sin(theta);
        createStone(getRandomGeometry(), x, z, a, b, cx, 0.01 + Math.random()*0.005);
    }
}

const paths = [
{ a1: 45.123, b1: 45.123, a2: 47.654, b2: 47.654, cx: 0, s: 2 },
 { a1: 46.789, b1: 46.789, a2: 49.321, b2: 49.321, cx: 0, s:50 },
 { a1: 47.456, b1: 47.456, a2: 50.987, b2: 50.987, cx: 0, s: 90 },
 { a1: 48.234, b1: 48.234, a2: 51.765, b2: 51.765, cx: 0, s: 100 },
 { a1: 49.876, b1: 49.876, a2: 52.543, b2: 52.543, cx: 0, s: 100 },
 { a1: 50.432, b1: 50.432, a2: 53.210, b2: 53.210, cx: 0, s: 100 },
 { a1: 51.098, b1: 51.098, a2: 54.876, b2: 54.876, cx: 0, s: 100 },
 { a1: 52.345, b1: 52.345, a2: 55.432, b2: 55.432, cx: 0, s: 90 },
 { a1: 53.210, b1: 53.210, a2: 56.789, b2: 56.789, cx: 0, s: 70 },
 { a1: 54.876, b1: 54.876, a2: 58.123, b2: 58.123, cx: 0, s: 500 },
 { a1: 57.876, b1: 57.876, a2: 58.123, b2: 58.123, cx: 0, s: 20 },
 { a1: 59.876, b1: 59.876, a2: 62.123, b2: 62.123, cx: 0, s: 20 },
 { a1: 59.876, b1: 59.876, a2: 64.123, b2: 64.123, cx: 0, s: 20 },
 { a1: 712, b1: 712, a2: 715, b2: 715, cx: 0, s: 1000 },
 { a1: 715, b1: 715, a2: 718, b2: 718, cx: 0, s: 1000 },
 { a1: 718, b1: 718, a2: 720, b2: 720, cx: 0, s: 1000 },
 { a1: 720, b1: 720, a2: 725, b2: 725, cx: 0, s: 2000 },
 { a1: 720, b1: 720, a2: 745, b2: 745, cx: 0, s: 2000 },
 { a1: 720, b1: 720, a2: 745, b2: 745, cx: 0, s: 2000 },
 { a1: 720, b1: 720, a2: 770, b2: 770, cx: 0, s: 2000 },
 { a1: 720, b1: 720, a2: 770, b2: 770, cx: 0, s: 2000 },
 { a1: 720, b1: 720, a2: 770, b2: 770, cx: 0, s: 2000 },
 { a1: 720, b1: 720, a2: 770, b2: 770, cx: 0, s: 2000 },
];

paths.forEach(p => placeStonesBetweenEllipses(p.a1,p.b1,p.a2,p.b2,p.cx,p.s));

// --- Orbital angles for planets ---
const angles = new Array(planets.length).fill(0);

// const pointLight = new THREE.PointLight(0xffffff, 2, 2000);
// pointLight.position.set(50, 50, 50);
// scene.add(pointLight);
scene.add(new THREE.AmbientLight(0x333333));

// ------------ Function: Create Sphere with Surface Particles ------------
function createSphereWithParticles(radius, numParticles, opacity, color, position) {
  const particlesGeometry = new THREE.BufferGeometry();
  const positions = [];

  for (let i = 0; i < numParticles; i++) {
    // Random direction on a sphere (normalized vector)
    const theta = Math.random() * Math.PI * 2;  // azimuth
    const phi = Math.acos(2 * Math.random() - 1); // polar angle
    const x = radius * Math.sin(phi) * Math.cos(theta);
    const y = radius * Math.sin(phi) * Math.sin(theta);
    const z = radius * Math.cos(phi);
    positions.push(x, y, z);
  }

  particlesGeometry.setAttribute(
    "position",
    new THREE.Float32BufferAttribute(positions, 3)
  );

  const particlesMaterial = new THREE.PointsMaterial({
    color: color,
    size: 0.3,
    transparent: true,
    opacity: opacity,
    blending: THREE.AdditiveBlending
  });

  const particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
  particleSystem.position.copy(position);
  scene.add(particleSystem);

  return particleSystem;
}

// ------------ Create Multiple Spheres with Particles ------------
const spheres = [];
// spheres.push(createSphereWithParticles(15, 300, 0.6, 0x00ffff, new THREE.Vector3(0, 0, 0)));
// spheres.push(createSphereWithParticles(25, 400, 0.4, 0xff00ff, new THREE.Vector3(50, 0, 0)));
spheres.push(createSphereWithParticles(1900, 200, 0.8, 0xff0f00, new THREE.Vector3(-50, 0, 0)));
spheres.push(createSphereWithParticles(1700, 200, 0.8, 0xf00f00, new THREE.Vector3(-50, 0, 0)));
spheres.push(createSphereWithParticles(1600, 200, 0.8, 0xefff00, new THREE.Vector3(-50, 0, 0)));
spheres.push(createSphereWithParticles(1500, 200, 0.8, 0xfeef00, new THREE.Vector3(-50, 0, 0)));
spheres.push(createSphereWithParticles(1400, 200, 0.8, 0xffef00, new THREE.Vector3(-50, 0, 0)));
spheres.push(createSphereWithParticles(1300, 200, 0.8, 0xff0000, new THREE.Vector3(-50, 0, 0)));
camera.position.set(0,65,0);
// --- Animation Loop ---
function animate(time){
    requestAnimationFrame(animate);

    // Planets orbit
    for(let i=1;i<planets.length;i++){
        angles[i] += planets[i].speed;
        const {a,b,cx} = orbitsData[i-1];
        const x = a * Math.cos(angles[i]) + cx;
        const z = b * Math.sin(angles[i]);
        planets[i].mesh.position.set(x,0,z);
    }

    // Move stones
    movingStones.forEach(stone => {
        stone.theta += stone.speed;
        stone.mesh.position.x = stone.cx + stone.a * Math.cos(stone.theta);
        stone.mesh.position.z = stone.b * Math.sin(stone.theta);
        stone.mesh.rotation.x -= 0.00;
        stone.mesh.rotation.y -= 0.001;
    });
  spheres.forEach((particleSystem) => {
    particleSystem.rotation.y += 0.001;
  });

    renderer.render(scene, camera);
    controls.update();
}

renderer.setAnimationLoop(animate);

// --- Resize ---
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

// --- Camera movement helper ---
// function moveCameraTo(x, y, z, duration = 2){
//     gsap.to(camera.position, {x, y, z, duration, onUpdate: ()=>controls.update()});
// }
</script>
</body>
</html>